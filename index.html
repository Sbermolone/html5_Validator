<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTML5 Creative Validator</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;background:linear-gradient(180deg,#e6f0fa 0%,#f8fbfe 100%);color:#1e3a5f}
  .panel{background:#fff;border-radius:1rem;box-shadow:0 4px 12px rgba(30,58,95,.1)}
  .badge{display:inline-flex;align-items:center;border-radius:9999px;padding:2px 10px;font-size:12px;font-weight:600;background:#0f3b82;color:#fff}
  .btn{background:#2563eb;color:#fff;padding:.5rem 1.25rem;border-radius:.75rem;font-weight:500}
  .btn:hover{background:#1d4ed8}
  #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:24px;z-index:50;background:#0f3b82;color:#fff;
         padding:10px 14px;border-radius:9999px;box-shadow:0 6px 18px rgba(15,59,130,.25);display:none}
  #alert{display:none}
  #previewCard{display:none}
  #previewFrame{width:100%;height:350px;border:1px solid #c7ddff;border-radius:.75rem;background:#fff}
  code.small{background:#eef5ff;padding:0 6px;border-radius:6px}
</style>
</head>
<body>
<div class="max-w-5xl mx-auto p-6">
  <header class="mb-6 text-center">
    <h1 class="text-3xl font-bold mb-2">HTML5 Creative Validator</h1>
    <p class="text-base text-blue-900">Upload your HTML5 banner ZIP and check it instantly.</p>
  </header>

  <!-- Error banner -->
  <div id="alert" class="mb-4 panel border border-red-200">
    <div class="p-4">
      <div class="flex items-start gap-3">
        <div class="mt-0.5 h-5 w-5 rounded-full bg-red-600 flex items-center justify-center text-white text-xs">!</div>
        <div class="flex-1">
          <div class="font-semibold text-red-700">Validation failed</div>
          <div id="alertMsg" class="mt-1 text-sm text-red-800"></div>
        </div>
        <button id="alertClose" class="text-red-700 hover:underline text-sm">Dismiss</button>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <section class="panel mb-6 p-6">
    <div class="flex flex-col md:flex-row md:items-end gap-4">
      <div class="flex-1">
        <label for="ruleset" class="block text-sm font-medium text-blue-900">Ruleset</label>
        <select id="ruleset" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
          <option value="cm360">CM360 (150KB initial / 2.2MB total)</option>
          <option value="dv360">DV360 (200KB initial / 5MB total)</option>
          <option value="gam">Google Ad Manager</option>
          <option value="custom">Custom…</option>
        </select>
      </div>
      <div class="flex-1">
        <label class="block text-sm font-medium text-blue-900">Initial load limit (KB)</label>
        <input id="initialKB" type="number" value="150" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
      </div>
      <div class="flex-1">
        <label class="block text-sm font-medium text-blue-900">Total load cap (KB)</label>
        <input id="totalKB" type="number" value="2200" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
      </div>
      <div class="flex-1">
        <label class="block text-sm font-medium text-blue-900">ZIP size cap (KB)</label>
        <input id="zipKB" type="number" value="200" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
      </div>
    </div>
    <div class="mt-4 flex flex-col gap-2">
      <div class="flex items-center gap-3">
        <input id="strictCM360" type="checkbox" class="rounded border-blue-300 text-blue-600 focus:ring-blue-400">
        <label for="strictCM360" class="text-sm text-blue-900">Strict CM360 mode (treat missing <code class="small">ad.size</code>, non-root <code class="small">index.html</code>, and external URLs as errors)</label>
      </div>
      <div class="flex items-center gap-3">
        <input id="blockAnchors" type="checkbox" class="rounded border-blue-300 text-blue-600 focus:ring-blue-400" checked>
        <label for="blockAnchors" class="text-sm text-blue-900">Disallow <code class="small">&lt;a&gt;</code> anchor tags</label>
      </div>
      <div class="flex items-center gap-3">
        <input id="blockProtocolRelative" type="checkbox" class="rounded border-blue-300 text-blue-600 focus:ring-blue-400" checked>
        <label for="blockProtocolRelative" class="text-sm text-blue-900">Treat protocol-relative URLs (<code class="small">//example.com</code>) as errors</label>
      </div>
    </div>
  </section>

  <!-- Dropzone -->
  <section id="dropzone" class="panel mb-8 p-8 text-center border-2 border-dashed border-blue-300 hover:border-blue-400 transition">
    <p class="text-lg font-medium text-blue-900">Drag & drop your ZIP here</p>
    <p class="text-sm text-blue-700 mb-3">or</p>
    <input id="fileInput" type="file" accept=".zip,application/zip,application/x-zip-compressed" class="block mx-auto mb-2">
    <div class="text-xs text-blue-800">Tip: if you pick the same file again, this still re-validates.</div>
    <div id="picked" class="mt-3 text-sm text-blue-800"></div>
  </section>

  <!-- Debug Console (auto-shows on errors) -->
  <section id="debugPanel" class="panel mb-6 p-4 hidden">
    <div class="flex items-center justify-between mb-2">
      <h3 class="font-semibold text-blue-900">Debug Console</h3>
      <button id="debugClear" class="text-sm text-blue-800 hover:underline">Clear</button>
    </div>
    <pre id="devlog" class="text-xs text-blue-900 bg-blue-50 rounded-lg p-3 overflow-auto max-h-48"></pre>
  </section>

  <!-- Summary -->
  <section id="results" class="hidden mb-6">
    <div id="summary" class="mb-4"></div>
  </section>

  <!-- Preview -->
  <section id="previewCard" class="panel mb-6 p-4">
    <div class="flex items-center justify-between mb-3">
      <h3 class="font-semibold text-blue-900">Preview</h3>
      <div class="text-xs text-blue-800">Sandboxed preview (assets served from memory)</div>
    </div>
    <iframe id="previewFrame" sandbox="allow-scripts allow-forms allow-pointer-lock allow-popups allow-modals allow-same-origin"></iframe>
  </section>

  <!-- Initial Load Breakdown -->
  <section id="initialBreakdown" class="panel mb-8 p-4 hidden">
    <h3 class="font-semibold text-blue-900 mb-2">Initial Load Breakdown</h3>
    <div class="text-xs text-blue-800 mb-3">Assets counted toward initial load and where they came from.</div>
    <div class="overflow-auto">
      <table class="w-full text-sm">
        <thead>
          <tr class="text-left text-blue-900">
            <th class="py-2 pr-3">Asset</th>
            <th class="py-2 pr-3">Source</th>
            <th class="py-2 pr-3">Size (KB)</th>
          </tr>
        </thead>
        <tbody id="initialRows"></tbody>
      </table>
    </div>
  </section>

  <!-- Details -->
  <section id="details" class="hidden mb-10">
    <div class="grid md:grid-cols-2 gap-6">
      <div class="panel p-4">
        <h2 class="font-semibold mb-2 text-blue-900">Errors</h2>
        <ul id="errors" class="list-disc pl-5 text-red-700"></ul>
      </div>
      <div class="panel p-4">
        <h2 class="font-semibold mb-2 text-blue-900">Warnings</h2>
        <ul id="warnings" class="list-disc pl-5 text-amber-600"></ul>
      </div>
    </div>
    <div class="mt-6 panel p-4">
      <h3 class="font-semibold mb-3 text-blue-900">Info</h3>
      <div id="info" class="text-sm text-blue-800 space-y-1"></div>
    </div>
    <div class="mt-6 flex flex-wrap gap-3">
      <button id="downloadJson" class="btn">Download JSON</button>
      <button id="downloadCsv" class="btn">Download CSV</button>
    </div>
  </section>
</div>

<div id="toast">Validating…</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const $ = s => document.querySelector(s);

  // Toast & alerts
  const showToast = (m="Validating…") => { const t=$("#toast"); t.textContent=m; t.style.display="block"; };
  const hideToast = () => { $("#toast").style.display="none"; };
  const escapeHtml = s => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  const showAlert = msgs => {
    const list = Array.isArray(msgs) ? msgs : [String(msgs)];
    $("#alertMsg").innerHTML = "<ul class='list-disc pl-5'>" + list.map(m => "<li>"+escapeHtml(m)+"</li>").join("") + "</ul>";
    $("#alert").style.display = "block";
  };
  const hideAlert = () => $("#alert").style.display="none";
  $("#alertClose").addEventListener("click", hideAlert);

  // === Debug console + global error hooks ===
  const debugPanel = document.querySelector('#debugPanel');
  const devlog = document.querySelector('#devlog');
  const debugClear = document.querySelector('#debugClear');
  const dbg = (...args) => {
    try {
      const msg = args.map(a => (typeof a==='string'? a : JSON.stringify(a))).join(' ');
      if (devlog) {
        devlog.textContent += msg + "
";
        if (debugPanel && debugPanel.classList.contains('hidden')) debugPanel.classList.remove('hidden');
      }
    } catch {}
  };
  if (debugClear) debugClear.addEventListener('click', ()=>{ if (devlog) devlog.textContent=''; });
  window.addEventListener('error', (e)=>{ const m = (e && e.message) ? e.message : 'Script error'; dbg('window.error:', m); });
  window.addEventListener('unhandledrejection', (e)=>{ const r = e && e.reason ? e.reason : ''; const m = (r && (r.message || r)) || 'Unhandled promise rejection'; dbg('unhandledrejection:', m); });

  // Rulesets UI
  const DEFAULT_RULESETS = {
    cm360:{initialKB:150,totalKB:2200,zipKB:200},
    dv360:{initialKB:200,totalKB:5000,zipKB:200},
    gam:{initialKB:150,totalKB:2200,zipKB:200},
    custom:{initialKB:150,totalKB:2200,zipKB:200}
  };
  const setRulesetUI = key => {
    const r = DEFAULT_RULESETS[key] || DEFAULT_RULESETS.custom;
    $("#initialKB").value = r.initialKB;
    $("#totalKB").value = r.totalKB;
    $("#zipKB").value = r.zipKB;
  };
  $("#ruleset").addEventListener("change", e => setRulesetUI(e.target.value));
  setRulesetUI("cm360");

  // Drag & drop
  const dropzone = $("#dropzone");
  dropzone.addEventListener("dragover", e => { e.preventDefault(); dropzone.classList.add("bg-blue-50"); });
  dropzone.addEventListener("dragleave", () => dropzone.classList.remove("bg-blue-50"));
  dropzone.addEventListener("drop", e => {
    e.preventDefault(); dropzone.classList.remove("bg-blue-50");
    const file = e.dataTransfer.files && e.dataTransfer.files[0];
    if (file) { $("#picked").textContent = `Selected: ${file.name}`; startValidation(file); }
  });

  // File input (re-trigger on same file)
  const input = $("#fileInput");
  input.addEventListener("click", () => { input.value = ""; });
  input.addEventListener("change", e => {
    const file = e.target.files && e.target.files[0];
    if (file) { $("#picked").textContent = `Selected: ${file.name}`; startValidation(file); }
  });

  // Helpers
  const bytesToKB = b => Math.round(b/1024);
  const bytesToMB = b => Math.round((b/(1024*1024))*100)/100;
  const setAdd = (set, vals) => { for (const v of vals) set.add(v); return set; };

  let previewUrls = [];

  function startValidation(file){
    hideAlert();
    showToast("Validating…");
    setTimeout(() => validateZip(file).catch(err => {
      hideToast(); showAlert(["Unexpected error while validating.", (err && err.message) ? err.message : String(err)]);
    }), 30);
  }

  async function validateZip(file){
    // Reset preview + breakdown
    previewUrls.forEach(URL.revokeObjectURL); previewUrls = [];
    $("#previewCard").style.display = "none";
    $("#previewFrame").src = "about:blank";
    $("#initialBreakdown").classList.add("hidden");
    $("#initialRows").innerHTML = "";

    const strict = $("#strictCM360").checked;
    const blockAnchors = $("#blockAnchors").checked;
    const blockProtocolRelative = $("#blockProtocolRelative").checked;

    const rules = {
      initialKB: +$("#initialKB").value || 150,
      totalKB: +$("#totalKB").value || 2200,
      zipKB: +$("#zipKB").value || 200
    };

    const errors = [], warnings = [], info = [], initialItems = [];
    const addError = m => errors.push(m);
    const addWarn  = m => warnings.push(m);
    const addInfo  = m => info.push(m);

    // ZIP size
    const zipSizeKB = bytesToKB(file.size);
    if (zipSizeKB > rules.zipKB) addError(`ZIP size ${zipSizeKB}KB exceeds cap ${rules.zipKB}KB.`);
    else addInfo(`ZIP size: ${zipSizeKB}KB`);

    // Load ZIP
    if (typeof JSZip === "undefined") { addError("ZIP parser (JSZip) failed to load. Check your internet connection or CDN blocking and reload the page."); return finish({errors,warnings,info,summaryStatus:"FAIL"}); }
    let zip;
    try { zip = await JSZip.loadAsync(await file.arrayBuffer()); }
    catch (err){ addError("Failed to read ZIP: " + err.message); return finish({errors,warnings,info,summaryStatus:"FAIL"}); }

    // Read entries
    const files = [];
    await Promise.all(Object.keys(zip.files).map(async (path) => {
      const entry = zip.files[path];
      if (entry.dir) return;
      const ext = (path.split('.').pop() || '').toLowerCase();
      const textLike = /^(html?|css|js|svg|txt|json)$/i.test(ext);
      let bin = null, text = "";
      try {
        bin = await entry.async("uint8array");
        if (textLike) { try { text = new TextDecoder("utf-8").decode(bin); } catch{} }
      } catch(e){}
      const size = bin ? bin.byteLength : ((entry._data && entry._data.uncompressedSize) || 0);
      files.push({ path, size, ext, bin, text });
    }));

    const totalBytes = files.reduce((s,f)=>s+f.size,0);
    const totalUnzippedKB = bytesToKB(totalBytes);
    addInfo(`Unzipped total: ${totalUnzippedKB}KB (${bytesToMB(totalBytes)}MB)`);

    // helpers
    const norm = p => (p||"").replace(/^\.?\//,'');
    const dirname = p => norm(p).replace(/\/[^\/]*$/,"");
    const filename = p => norm(p).split('/').pop();
    const fileSizeMap = new Map(files.map(f => [norm(f.path), f.size]));
    const fileTextMap = new Map(files.map(f => [norm(f.path), f.text]));
    const fileSet     = new Set(files.map(f => norm(f.path)));

    // Entry html
    const htmlFiles = files.filter(f => /\.html?$/i.test(f.path));
    const indexFile = htmlFiles.find(f => /(^|\/)index\.html$/i.test(f.path));
    if (!indexFile) addError("Missing index.html.");
    else if (!/^index\.html$/i.test(indexFile.path)) (strict?addError:addWarn)(`index.html is nested at ${indexFile.path}. Many ad servers expect it at the root.`);
    const idxDir = indexFile ? dirname(indexFile.path) : "";

    // Unsupported/blocked file types (whitelist preferred)
    const ALLOWED_EXT = new Set(['html','htm','js','mjs','css','json','png','jpg','jpeg','gif','svg','webp','mp4','webm','woff','woff2','txt']);
    const BLOCKED_EXT = /(exe|bat|cmd|sh|php|py|jar|dll)$/i;
    const unsupported = files.filter(f => !ALLOWED_EXT.has(f.ext));
    const blocked = files.filter(f => BLOCKED_EXT.test(f.path));
    if (unsupported.length) addWarn(`Unsupported file types present: ${unsupported.map(f=>f.path).join(', ')}`);
    if (blocked.length) addError(`Blocked file types present: ${blocked.map(f=>f.path).join(', ')}`);

    // Global URL collectors
    const externalUrls = new Set();
    const httpUrls = new Set();
    const protocolRelative = new Set();
    const localRefs = new Set(); // referenced local asset paths

    // CSS URL extractor
    const extractCssUrls = (cssText, baseDir) => {
      cssText.replace(/url\(([^)]+)\)/g, (m, raw) => {
        let ref = raw.trim().replace(/^['"]|['"]$/g,"");
        if (/^data:|^https?:|^\/\//i.test(ref) || /^#/.test(ref)) {
          if (/^https?:/i.test(ref)) externalUrls.add(ref);
          if (/^http:\/\//i.test(ref)) httpUrls.add(ref);
          if (/^\/\//.test(ref)) protocolRelative.add(ref);
          return m;
        }
        const joined = norm(baseDir ? (baseDir + "/" + ref) : ref);
        localRefs.add(joined);
        return m;
      });
    };

    // JS string URL extractor + click/unsafe API signals
    let hasClickTag=false, hasEnablerExit=false, hardcodedOpen=false, multiExits=0, usesEval=false, usesFunctionCtor=false, usesDocWrite=false, tightInterval=false, usesTopOrParent=false, usesConsole=false, hasDebugger=false;

    const scanJsText = (txt) => {
      if (!txt) return;
      // URLs in JS strings
      (txt.match(/["']https?:\\/\\/[^"']+["']/g) || []).forEach(s => {
        const u = s.slice(1,-1);
        externalUrls.add(u);
        if (/^http:\/\//i.test(u)) httpUrls.add(u);
      });
      (txt.match(/["']\\/\\/[^"']+["']/g) || []).forEach(s => protocolRelative.add(s.slice(1,-1)));
      // click handling & hazards
      if (/\b(clickTag\d*)\b/i.test(txt)) { hasClickTag = true; }
      const exitMatches = txt.match(/Enabler\s*\.\s*(exit|exitOverride)\s*\(/g); if (exitMatches) { hasEnablerExit = true; }
      if (/window\s*\.\s*open\s*\(\s*['"]https?:\/\//i.test(txt)) hardcodedOpen = true;
      if (/clickTag\d+/i.test(txt)) multiExits = Math.max(multiExits, (txt.match(/clickTag\d+/gi)||[]).length);
      if (/\beval\s*\(/.test(txt)) usesEval = true;
      if (/new\s+Function\s*\(/.test(txt)) usesFunctionCtor = true;
      if (/document\s*\.\s*write\s*\(/.test(txt)) usesDocWrite = true;
      if (/setInterval\s*\(\s*[^,]+,\s*(\d+)\s*\)/.test(txt)) {
        const m = txt.match(/setInterval\s*\(\s*[^,]+,\s*(\d+)\s*\)/);
        if (m && +m[1] < 10) tightInterval = true;
      }
      if (/(?:^|\W)(?:top\.|parent\.)/.test(txt)) usesTopOrParent = true;
      if (/console\./.test(txt)) usesConsole = true;
      if (/\bdebugger\b/.test(txt)) hasDebugger = true;
    };

    // HTML parse helper
    const parseHtml = (text) => new DOMParser().parseFromString(text, "text/html");

    // Scan HTML files
    for (const f of htmlFiles){
      const doc = parseHtml(f.text || "");

      // Collect src/href
      doc.querySelectorAll('[src], [href], [poster]').forEach(el => {
        const attr = el.getAttribute('src') || el.getAttribute('href') || el.getAttribute('poster');
        if (!attr) return;
        if (/^data:|^mailto:|^tel:|^#/.test(attr)) return;
        if (/^https?:\/\//i.test(attr)) { externalUrls.add(attr); if (/^http:\/\//i.test(attr)) httpUrls.add(attr); }
        else if (/^\/\//.test(attr)) { protocolRelative.add(attr); }
        else {
          // local ref
          const baseDir = dirname(f.path);
          const joined = norm(baseDir ? (baseDir+"/"+attr.replace(/^\.?\//,'')) : attr.replace(/^\.?\//,''));
          localRefs.add(joined.split('?')[0]);
        }
      });

      // Anchor tags rule
      if (blockAnchors && /<\s*a(\s|>)/i.test(f.text || "")) addError(`Anchor tag <a> found in ${f.path}. Use clickTag/Enabler instead of anchors.`);

      // Autoplay with sound
      doc.querySelectorAll('video[autoplay], audio[autoplay]').forEach(el => {
        if (!el.hasAttribute('muted')) addError(`Autoplay with sound risk in ${f.path}: <${el.tagName.toLowerCase()}> should include muted when autoplaying.`);
      });

      // Inline styles url()
      doc.querySelectorAll('[style]').forEach(el => extractCssUrls(el.getAttribute('style') || '', dirname(f.path)));

      // Linked CSS content
      doc.querySelectorAll('link[rel="stylesheet"][href]').forEach(link => {
        const href = link.getAttribute('href');
        if (!href || /^https?:|^\/\//i.test(href)) return;
        const cssPath = norm((dirname(f.path) ? dirname(f.path) + '/' : '') + href.replace(/^\.?\//,''));
        const cssText = fileTextMap.get(cssPath) || '';
        extractCssUrls(cssText, dirname(cssPath));
      });

      // <style> blocks
      doc.querySelectorAll('style').forEach(s => extractCssUrls(s.textContent || '', dirname(f.path)));

      // Click handling signals from HTML
      const htmlText = f.text || '';
      if (/\b(clickTag|clickTAG|clicktag)\b/.test(htmlText)) hasClickTag = true;
      if (/\bEnabler\s*\.\s*exit\s*\(/.test(htmlText)) hasEnablerExit = true;
      if (/document\.write\(/.test(htmlText)) usesDocWrite = true;
    }

    // Scan JS files for URLs & patterns
    for (const f of files.filter(x => x.ext === 'js' || x.ext === 'mjs')) scanJsText(f.text || '');

    // Protocol-relative policy
    if (protocolRelative.size) (blockProtocolRelative?addError:addWarn)(`Protocol-relative URLs found: ${Array.from(protocolRelative).slice(0,3).join(', ')}…`);

    // HTTPS only
    if (httpUrls.size) addError(`Insecure HTTP URLs found: ${Array.from(httpUrls).slice(0,3).join(', ')}… Use HTTPS.`);

    // External dependency policy
    if (externalUrls.size) (strict?addError:addWarn)(`External asset URLs found (${externalUrls.size}). Examples: ${Array.from(externalUrls).slice(0,3).join(', ')}`);

    // ad.size (index.html only)
    if (indexFile && indexFile.text){
      const doc = parseHtml(indexFile.text);
      const meta = doc.querySelector('meta[name="ad.size"]');
      if (meta && meta.content) addInfo(`ad.size: ${meta.content}`);
      else (strict?addError:addWarn)('Missing <meta name="ad.size">.');
    }

    // Initial load estimation (from index.html references + css)
    let initialAssetBytes = 0;
    if (indexFile && indexFile.text){
      const doc = parseHtml(indexFile.text);
      const refPairs = [];
      const pushRef = (url, source) => url && refPairs.push({url, source});
      doc.querySelectorAll("img[src]").forEach(el => pushRef(el.getAttribute("src"), "<img src>"));
      doc.querySelectorAll('link[rel="stylesheet"][href]').forEach(el => pushRef(el.getAttribute("href"), '<link rel="stylesheet" href>'));
      doc.querySelectorAll("script[src]").forEach(el => pushRef(el.getAttribute("src"), "<script src>"));
      doc.querySelectorAll("video source[src]").forEach(el => pushRef(el.getAttribute("src"), "<video> source[src]"));
      doc.querySelectorAll("audio source[src]").forEach(el => pushRef(el.getAttribute("src"), "<audio> source[src]"));

      const resolveFromIndex = u => {
        let rr = (u||"").replace(/^\.?\//,'');
        if (/^data:|^https?:|^\/\//i.test(rr) || /^#/.test(rr)) return null;
        return norm(idxDir ? (idxDir + "/" + rr) : rr);
      };

      // Direct refs
      for (const {url, source} of refPairs){
        const p = resolveFromIndex(url); if (!p) continue;
        const size = fileSizeMap.get(p);
        if (size){ initialAssetBytes += size; initialItems.push({path:p, size, source}); }
        localRefs.add((p||'').split('?')[0]);
      }

      // Linked CSS (again for initial)
      const linkedCss = refPairs.filter(r => r.source.includes("stylesheet")).map(r => resolveFromIndex(r.url)).filter(Boolean);
      for (const cssPath of linkedCss){
        const cssText = fileTextMap.get(cssPath) || "";
        const baseDir = dirname(cssPath);
        cssText.replace(/url\(([^)]+)\)/g, (m, raw) => {
          let ref = raw.trim().replace(/^['"]|['"]$/g,"");
          if (/^data:|^https?:|^\/\//i.test(ref) || /^#/.test(ref)) return m;
          let joined = norm(baseDir ? (baseDir + "/" + ref) : ref);
          const size = fileSizeMap.get(joined);
          if (size){ initialAssetBytes += size; initialItems.push({path:joined, size, source:`${cssPath} → url(...)`}); }
          localRefs.add(joined.split('?')[0]);
          return m;
        });
      }

      // <style> blocks in index
      Array.from(doc.querySelectorAll("style")).forEach(s => {
        const cssText = s.textContent || "";
        cssText.replace(/url\(([^)]+)\)/g, (m, raw) => {
          let ref = raw.trim().replace(/^['"]|['"]$/g,"");
          if (/^data:|^https?:|^\/\//i.test(ref) || /^#/.test(ref)) return m;
          let joined = norm(idxDir ? (idxDir + "/" + ref) : ref);
          const size = fileSizeMap.get(joined);
          if (size){ initialAssetBytes += size; initialItems.push({path:joined, size, source:`inline <style> → url(...)`}); }
          localRefs.add(joined.split('?')[0]);
          return m;
        });
      });
    }

    // Missing local asset check (zip vs referenced)
    const missing = Array.from(localRefs).filter(p => !fileSet.has(p));
    if (missing.length) addError(`Missing assets referenced by HTML/CSS/JS: ${missing.slice(0,10).join(', ')}${missing.length>10?'…':''}`);

    // Click handling policy
    if (!hasClickTag && !hasEnablerExit) addError("Missing click handling: expected global clickTag or Studio Enabler.exit().");
    else addInfo("Click handling detected: " + [hasClickTag ? "clickTag" : null, hasEnablerExit ? "Enabler.exit" : null].filter(Boolean).join(" + "));
    if (hardcodedOpen) addError("Hard-coded URL open detected (window.open('https://…')). Use clickTag/Enabler.exit.");
    if (multiExits > 1) addWarn(`Multiple clickTags detected (${multiExits}). Ensure mapping is intentional.`);

    // Hazardous APIs & hygiene
    if (usesDocWrite) addWarn("Usage of document.write() detected; discouraged for ads.");
    if (usesEval) addWarn("eval() detected; avoid dynamic code execution.");
    if (usesFunctionCtor) addWarn("new Function(...) detected; avoid dynamic code execution.");
    if (tightInterval) addWarn("Very tight setInterval detected (<10ms); may impact CPU.");
    if (usesTopOrParent) addWarn("References to top./parent. detected; frame-busting may be blocked.");
    if (usesConsole) addWarn("console.* statements present; remove before trafficking.");
    if (hasDebugger) addWarn("'debugger' statements present; remove for production.");

    // HTTPS + size budget checks
    const initialKB = bytesToKB(initialAssetBytes);
    if (initialKB > rules.initialKB) addError(`Estimated initial load ${initialKB}KB exceeds cap ${rules.initialKB}KB.`);
    else addInfo(`Estimated initial load: ${initialKB}KB`);
    if (totalUnzippedKB > rules.totalKB) addError(`Total unzipped size ${totalUnzippedKB}KB exceeds cap ${rules.totalKB}KB.`);

    // SVG inline <script> rule
    for (const f of files.filter(x => x.ext === 'svg')){
      if (/<\s*script\b/i.test(f.text || '')) addWarn(`Inline <script> inside SVG found: ${f.path}. Often blocked by ad platforms.`);
    }

    // Preview
    if (indexFile) { try { await buildPreview(files, indexFile, previewUrls); } catch(e){ addWarn("Preview rendering failed: " + ((e && e.message) ? e.message : e)); } }

    // Breakdown table
    if (initialItems.length){
      $("#initialBreakdown").classList.remove("hidden");
      $("#initialRows").innerHTML = initialItems.sort((a,b)=>b.size-a.size)
        .map(it => `<tr class="border-t border-blue-100"><td class="py-2 pr-3 text-blue-900 break-all">${escapeHtml(it.path)}</td><td class="py-2 pr-3 text-blue-800">${escapeHtml(it.source)}</td><td class="py-2 pr-3">${bytesToKB(it.size)}</td></tr>`).join("");
    }

    const summaryStatus = errors.length ? "FAIL" : (warnings.length ? "WARN" : "PASS");
    return finish({errors,warnings,info,summaryStatus,meta:{zipKB:zipSizeKB,totalKB:totalUnzippedKB,initialKB}});
  }

  function finish(payload){
    hideToast();
    if (payload.summaryStatus === "FAIL") showAlert(payload.errors?.length ? payload.errors : "The file failed validation.");
    else hideAlert();
    showResults(payload);
  }

  function showResults({errors,warnings,info,summaryStatus}){
    $("#results").classList.remove("hidden");
    $("#details").classList.remove("hidden");

    const tone = summaryStatus==="PASS" ? "bg-blue-100 border-blue-300" :
                 summaryStatus==="WARN" ? "bg-blue-50 border-blue-200" :
                 "bg-blue-50 border-blue-300";
    $("#summary").innerHTML =
      `<div class="rounded-2xl border p-4 ${tone}">
         <div class="flex items-center gap-3">
           <div class="badge">${summaryStatus}</div>
           <div class="text-sm text-blue-900">
             Errors: <strong>${errors.length}</strong> · Warnings: <strong>${warnings.length}</strong>
           </div>
         </div>
       </div>`;

    const eul=$("#errors"); eul.innerHTML=""; errors.forEach(e=>{const li=document.createElement("li"); li.textContent=e; eul.appendChild(li);});
    const wul=$("#warnings"); wul.innerHTML=""; warnings.forEach(w=>{const li=document.createElement("li"); li.textContent=w; wul.appendChild(li);});
    const inf=$("#info"); inf.innerHTML=""; info.forEach(i=>{const p=document.createElement("div"); p.textContent="• "+i; inf.appendChild(p);});

    // downloads
    const payload = { status: summaryStatus, errors, warnings, info };
    $("#downloadJson").onclick = () => downloadBlob(JSON.stringify(payload,null,2),"h5-validator-results.json","application/json");
    const rows = [].concat(errors.map(m=>({category:"ERROR",message:m}))).concat(warnings.map(m=>({category:"WARNING",message:m})));
    const csv = "category,message\n" + rows.map(r => JSON.stringify(r.category)+","+JSON.stringify(r.message)).join("\n");
    $("#downloadCsv").onclick = () => downloadBlob(csv,"h5-validator-results.csv","text/csv");
  }

  function downloadBlob(content, filename, type){
    const blob = new Blob([content], {type});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href=url; a.download=filename;
    document.body.appendChild(a); a.click();
    setTimeout(()=>{URL.revokeObjectURL(url); a.remove();}, 200);
  }

  // Preview builder
  const MIME = {html:"text/html",htm:"text/html",css:"text/css",js:"text/javascript",mjs:"text/javascript",
    png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif",webp:"image/webp",svg:"image/svg+xml",
    mp4:"video/mp4",webm:"video/webm",ogg:"video/ogg",mp3:"audio/mpeg",wav:"audio/wav",json:"application/json",
    txt:"text/plain",woff:"font/woff",woff2:"font/woff2",ttf:"font/ttf",otf:"font/otf"};

  async function buildPreview(files, indexFile, previewUrls){
    const urlMap = new Map();
    const norm = p => (p||"").replace(/^\.?\//,'');
    const dirOf = p => norm(p).replace(/\/[^\/]*$/,"");

    // blobs for all
    for (const f of files){
      if (!f.bin) continue;
      const blob = new Blob([f.bin], {type: MIME[f.ext] || "application/octet-stream"});
      const u = URL.createObjectURL(blob); urlMap.set(norm(f.path), u); previewUrls.push(u);
    }

    // rewrite CSS
    for (const f of files.filter(x => (x.ext==="css") && typeof x.text==="string")){
      const baseDir = dirOf(f.path);
      const rewritten = (f.text||"").replace(/url\(([^)]+)\)/g,(m,raw)=>{
        let ref = raw.trim().replace(/^['"]|['"]$/g,"");
        if (/^data:|^https?:|^\/\//i.test(ref)) return m;
        const joined = norm(baseDir ? (baseDir+"/"+ref) : ref);
        const target = urlMap.get(joined);
        return target ? `url(${target})` : m;
      });
      const blob = new Blob([rewritten], {type:"text/css"});
      const u = URL.createObjectURL(blob); previewUrls.push(u);
      urlMap.set(norm(f.path), u);
    }

    // rewrite index.html
    const parser = new DOMParser();
    const doc = parser.parseFromString(indexFile.text||"", "text/html");
    const rewriteAttr = (sel,attr)=>{
      doc.querySelectorAll(sel).forEach(el=>{
        const v = el.getAttribute(attr);
        if (!v || /^data:|^https?:|^\/\//i.test(v) || /^#/.test(v)) return;
        const idxDir = dirOf(indexFile.path);
        let joined = v.replace(/^\.?\//,''); if (idxDir) joined = (idxDir+"/"+joined).replace(/^\//,'');
        const blobUrl = urlMap.get(norm(joined)); if (blobUrl) el.setAttribute(attr, blobUrl);
      });
    };
    rewriteAttr("script[src]","src");
    rewriteAttr('link[rel="stylesheet"][href]','href');
    rewriteAttr("img[src]","src");
    rewriteAttr("video source[src]","src");
    rewriteAttr("audio source[src]","src");

    const htmlUrl = URL.createObjectURL(new Blob(["<!DOCTYPE html>\n"+doc.documentElement.outerHTML], {type:"text/html"}));
    previewUrls.push(htmlUrl);
    const frame = document.querySelector("#previewFrame");
    frame.src = htmlUrl;
    document.querySelector("#previewCard").style.display = "block";
  }
});
</script>
</body>
</html>
