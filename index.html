<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>HTML5 Creative Validator</title>
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(180deg, #e6f0fa 0%, #f8fbfe 100%);
      color: #1e3a5f;
    }
    .badge {
      display:inline-flex; align-items:center; border-radius:9999px;
      padding:2px 10px; font-size:12px; font-weight:600;
      background:#0f3b82; color:#fff;
    }
    .panel {
      background:#fff; border-radius:1rem;
      box-shadow:0 4px 12px rgba(30,58,95,0.1);
    }
    .btn-main {
      background:#2563eb; color:#fff; padding:0.5rem 1.25rem;
      border-radius:0.75rem; font-weight:500;
    }
    .btn-main:hover { background:#1d4ed8; }
    /* Toast */
    #toast {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 24px; z-index: 50;
      background: #0f3b82; color: #fff;
      padding: 10px 14px; border-radius: 9999px;
      box-shadow: 0 6px 18px rgba(15,59,130,0.25);
      display: none;
    }
    /* Alert */
    #alert { display:none; }
    /* Preview */
    #previewCard { display:none; }
    #previewFrame {
      width: 100%;
      height: 350px; /* you can change this or make it dynamic */
      border: 1px solid #c7ddff;
      border-radius: 0.75rem;
      background: #fff;
    }
  </style>
</head>
<body>
  <div class="max-w-5xl mx-auto p-6">
    <header class="mb-6 text-center">
      <h1 class="text-3xl font-bold mb-2">HTML5 Creative Validator</h1>
      <p class="text-base text-blue-900">Upload your HTML5 banner ZIP and check it instantly.</p>
    </header>

    <!-- Error banner -->
    <div id="alert" class="mb-4 panel border border-red-200">
      <div class="p-4">
        <div class="flex items-start gap-3">
          <div class="mt-0.5 h-5 w-5 rounded-full bg-red-600 flex items-center justify-center text-white text-xs">!</div>
          <div class="flex-1">
            <div class="font-semibold text-red-700">Validation failed</div>
            <div id="alertMsg" class="mt-1 text-sm text-red-800"></div>
          </div>
          <button id="alertClose" class="text-red-700 hover:underline text-sm">Dismiss</button>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <section class="panel mb-6 p-6">
      <div class="flex flex-col md:flex-row md:items-end gap-4">
        <div class="flex-1">
          <label for="ruleset" class="block text-sm font-medium text-blue-900">Ruleset</label>
          <select id="ruleset" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
            <option value="cm360">CM360 (150KB initial / 2.2MB total)</option>
            <option value="dv360">DV360 (200KB initial / 5MB total)</option>
            <option value="gam">Google Ad Manager</option>
            <option value="custom">Custom…</option>
          </select>
        </div>
        <div class="flex-1">
          <label class="block text-sm font-medium text-blue-900">Initial load limit (KB)</label>
          <input id="initialKB" type="number" value="150" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
        </div>
        <div class="flex-1">
          <label class="block text-sm font-medium text-blue-900">Total load cap (KB)</label>
          <input id="totalKB" type="number" value="2200" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
        </div>
        <div class="flex-1">
          <label class="block text-sm font-medium text-blue-900">ZIP size cap (KB)</label>
          <input id="zipKB" type="number" value="200" class="mt-1 w-full rounded-lg border-blue-200 focus:ring-blue-400 focus:border-blue-400">
        </div>
      </div>
    </section>

    <!-- Dropzone -->
    <section id="dropzone" class="panel mb-8 p-8 text-center border-2 border-dashed border-blue-300 hover:border-blue-400 transition">
      <input type="file" id="fileInput" accept=".zip" class="hidden"/>
      <p class="text-lg font-medium text-blue-900">Drag & drop your ZIP here</p>
      <p class="text-sm text-blue-700">or</p>
      <label for="fileInput" class="btn-main cursor-pointer mt-3 inline-block">Browse…</label>
      <div id="picked" class="mt-3 text-sm text-blue-800"></div>
    </section>

    <!-- Results Summary -->
    <section id="results" class="hidden mb-6">
      <div id="summary" class="mb-4"></div>
    </section>

    <!-- Preview (between summary and error lists) -->
    <section id="previewCard" class="panel mb-8 p-4">
      <div class="flex items-center justify-between mb-3">
        <h3 class="font-semibold text-blue-900">Preview</h3>
        <div class="text-xs text-blue-800" id="previewHint">Sandboxed preview (assets served from memory)</div>
      </div>
      <iframe id="previewFrame" sandbox="allow-scripts allow-forms allow-pointer-lock allow-popups allow-modals"></iframe>
    </section>

    <!-- Detailed results -->
    <section id="details" class="hidden mb-10">
      <div class="grid md:grid-cols-2 gap-6">
        <div class="panel p-4">
          <h2 class="font-semibold mb-2 text-blue-900">Errors</h2>
          <ul id="errors" class="list-disc pl-5 text-red-700"></ul>
        </div>
        <div class="panel p-4">
          <h2 class="font-semibold mb-2 text-blue-900">Warnings</h2>
          <ul id="warnings" class="list-disc pl-5 text-amber-600"></ul>
        </div>
      </div>
      <div class="mt-6 panel p-4">
        <h3 class="font-semibold mb-3 text-blue-900">Info</h3>
        <div id="info" class="text-sm text-blue-800 space-y-1"></div>
      </div>
      <div class="mt-6 flex flex-wrap gap-3">
        <button id="downloadJson" class="btn-main">Download JSON</button>
        <button id="downloadCsv" class="btn-main">Download CSV</button>
      </div>
    </section>
  </div>

  <!-- Toast -->
  <div id="toast">Validating…</div>

  <script>
    const $ = (sel) => document.querySelector(sel);

    // Toast helpers
    function showToast(msg="Validating…") { const t=$("#toast"); t.textContent=msg; t.style.display="block"; }
    function hideToast(){ $("#toast").style.display="none"; }

    // Alert helpers
    function showAlert(messages) {
      const list = Array.isArray(messages) ? messages : [String(messages)];
      $("#alertMsg").innerHTML = "<ul class='list-disc pl-5'>" +
        list.map(m => "<li>"+escapeHtml(m)+"</li>").join("") + "</ul>";
      $("#alert").style.display = "block";
    }
    function hideAlert(){ $("#alert").style.display="none"; }
    $("#alertClose").addEventListener("click", hideAlert);
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

    const DEFAULT_RULESETS = {
      cm360: { initialKB: 150, totalKB: 2200, zipKB: 200, requireClickTag: true, allowHttp: false },
      dv360: { initialKB: 200, totalKB: 5000, zipKB: 200, requireClickTag: true, allowHttp: false },
      gam:   { initialKB: 150, totalKB: 2200, zipKB: 200, requireClickTag: true, allowHttp: false },
      custom:{ initialKB: 150, totalKB: 2200, zipKB: 200, requireClickTag: true, allowHttp: false }
    };

    function setRulesetUI(key) {
      const r = DEFAULT_RULESETS[key] || DEFAULT_RULESETS.custom;
      $("#initialKB").value = r.initialKB;
      $("#totalKB").value   = r.totalKB;
      $("#zipKB").value     = r.zipKB;
    }
    $("#ruleset").addEventListener("change", (e) => setRulesetUI(e.target.value));
    setRulesetUI("cm360");

    // Drag & drop
    const dropzone = $("#dropzone");
    dropzone.addEventListener("dragover", (e) => { e.preventDefault(); dropzone.classList.add("bg-blue-50"); });
    dropzone.addEventListener("dragleave", () => dropzone.classList.remove("bg-blue-50"));
    dropzone.addEventListener("drop", (e) => {
      e.preventDefault();
      dropzone.classList.remove("bg-blue-50");
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) { $("#picked").textContent = `Selected: ${file.name}`; startValidation(file); }
    });

    // File selection
    $("#fileInput").addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (file) { $("#picked").textContent = `Selected: ${file.name}`; startValidation(file); }
    });

    function bytesToKB(b){ return Math.round(b / 1024); }
    function bytesToMB(b){ return Math.round((b / (1024*1024)) * 100)/100; }

    let previewUrls = []; // track blob URLs to revoke

    function startValidation(file){
      hideAlert();
      showToast("Validating…");
      setTimeout(() => validateZip(file).catch(err => {
        hideToast();
        showAlert(["Unexpected error while validating.", err && err.message ? err.message : String(err)]);
      }), 50);
    }

    async function validateZip(file){
      // Revoke prior preview URLs
      previewUrls.forEach(URL.revokeObjectURL);
      previewUrls = [];
      $("#previewCard").style.display = "none";
      $("#previewFrame").src = "about:blank";

      const rules = {
        initialKB: +$("#initialKB").value || 150,
        totalKB: +$("#totalKB").value || 2200,
        zipKB: +$("#zipKB").value || 200,
        requireClickTag: true,
        allowHttp: false
      };
      const errors = [];
      const warnings = [];
      const info = [];
      let summaryStatus = "PASS";

      const zipSizeKB = bytesToKB(file.size);
      if (zipSizeKB > rules.zipKB) errors.push(`ZIP size ${zipSizeKB}KB exceeds cap ${rules.zipKB}KB.`);
      else info.push(`ZIP size: ${zipSizeKB}KB`);

      let zip;
      try {
        const ab = await file.arrayBuffer();
        zip = await JSZip.loadAsync(ab);
      } catch (err){
        errors.push("Failed to read ZIP: " + err.message);
        return finish({errors,warnings,info,summaryStatus:"FAIL"});
      }

      // Read entries
      const files = [];
      const names = Object.keys(zip.files);
      await Promise.all(names.map(async (path) => {
        const entry = zip.files[path];
        if (entry.dir) return;
        const ext = (path.split('.').pop() || '').toLowerCase();
        const textLike = /^(html?|css|js|svg|txt|json)$/i.test(ext);
        let bin = null, text = "";
        try {
          bin = await entry.async("uint8array");
          if (textLike) {
            try { text = new TextDecoder("utf-8").decode(bin); } catch {}
          }
        } catch(e){}
        const size = bin ? bin.byteLength : (entry._data?.uncompressedSize || 0);
        files.push({ path, size, ext, bin, text });
      }));

      const totalBytes = files.reduce((s,f)=>s+f.size,0);
      const totalUnzippedKB = bytesToKB(totalBytes);
      info.push(`Unzipped total: ${totalUnzippedKB}KB (${bytesToMB(totalBytes)}MB)`);

      // index.html
      const indexFile = files.find(f => /(^|\/)index\.html$/i.test(f.path));
      if (!indexFile) errors.push("Missing index.html.");
      else if (!/^index\.html$/i.test(indexFile.path)) warnings.push(`index.html is nested at ${indexFile.path}. Many ad servers expect it at the root.`);

      // Blocked file types
      const blocked = files.filter(f => /\.(exe|bat|cmd|sh|php|py|jar|dll)$/i.test(f.path));
      if (blocked.length) errors.push(`Blocked file types present: ${blocked.map(f=>f.path).join(", ")}`);

      // External URLs & HTTP
      const extUrlPattern = /\b(?:src|href)\s*=\s*["']([^"']+)["']/gi;
      const externalUrls = new Set();
      const httpUrls = new Set();
      for (const f of files){
        if (!f.text) continue;
        let m; const t = f.text;
        while ((m = extUrlPattern.exec(t)) !== null) {
          const url = m[1];
          if (/^data:|^mailto:|^tel:|^#/.test(url)) continue;
          if (/^https?:\/\//i.test(url) || /^\/\//.test(url)) {
            externalUrls.add(url);
            if (/^http:\/\//i.test(url)) httpUrls.add(url);
          }
        }
      }
      if (externalUrls.size) warnings.push(`External asset URLs found (${externalUrls.size}). Consider packaging locally. Examples: ${Array.from(externalUrls).slice(0,3).join(", ")}`);
      if (httpUrls.size) errors.push(`Insecure HTTP URLs found: ${Array.from(httpUrls).slice(0,3).join(", ")}… Use HTTPS.`);

      // ad.size + refs + click handling
      let initialAssetBytes = 0;
      let hasClickTag = false;
      let hasEnablerExit = false;
      function normalize(p){ return (p || "").replace(/^\.?\//,''); }

      if (indexFile && indexFile.text){
        try {
          const parser = new DOMParser();
          const doc = parser.parseFromString(indexFile.text, "text/html");

          const meta = doc.querySelector('meta[name="ad.size"]');
          if (meta && meta.content) { info.push(`ad.size: ${meta.content}`); }
          else { warnings.push('Missing <meta name="ad.size"> (often required).'); }

          const refs = [];
          doc.querySelectorAll("script[src], link[rel=stylesheet][href], img[src], video source[src], audio source[src]")
            .forEach(el => { const url = el.getAttribute("src") || el.getAttribute("href"); if (url) refs.push(url); });

          const idxDir = indexFile.path.replace(/\/index\.html$/i, "");
          const normalized = new Set(refs.map(r => {
            let rr = r.replace(/^\.?\//,'');
            if (!/^[a-z]+:|^\/\//i.test(rr) && idxDir) rr = (idxDir + "/" + rr).replace(/^\//,'');
            return rr;
          }));

          for (const f of files){
            const name = normalize(f.path);
            if (normalized.has(name)) initialAssetBytes += f.size;
          }

          const html = indexFile.text;
          hasClickTag = /\b(clickTag|clickTAG|clicktag)\b/.test(html);
          hasEnablerExit = /\bEnabler\s*\.\s*exit\s*\(/.test(html);
        } catch(e){
          warnings.push("Unable to parse index.html DOM cleanly.");
        }
      }

      // JS scan too
      if (!hasClickTag || !hasEnablerExit){
        const jsMatchesCT = files.some(f => f.ext === "js" && /\b(clickTag|clickTAG|clicktag)\b/.test(f.text || ""));
        const jsMatchesEn = files.some(f => f.ext === "js" && /\bEnabler\s*\.\s*exit\s*\(/.test(f.text || ""));
        hasClickTag = hasClickTag || jsMatchesCT;
        hasEnablerExit = hasEnablerExit || jsMatchesEn;
      }

      if (!hasClickTag && !hasEnablerExit) errors.push("Missing click handling: expected global clickTag or Studio Enabler.exit().");
      else info.push("Click handling detected: " + [hasClickTag ? "clickTag" : null, hasEnablerExit ? "Enabler.exit" : null].filter(Boolean).join(" + "));

      // document.write usage
      const usesDocWrite = files.some(f => (f.text||"").includes("document.write("));
      if (usesDocWrite) warnings.push("Usage of document.write() detected; often discouraged for ads.");

      // Size checks
      const initialKB = bytesToKB(initialAssetBytes);
      if (initialKB > rules.initialKB) errors.push(`Estimated initial load ${initialKB}KB exceeds cap ${rules.initialKB}KB.`);
      else info.push(`Estimated initial load: ${initialKB}KB`);
      if (totalUnzippedKB > rules.totalKB) errors.push(`Total unzipped size ${totalUnzippedKB}KB exceeds cap ${rules.totalKB}KB.`);

      // Build preview (only if index.html exists)
      if (indexFile) {
        try {
          await buildPreview(files, indexFile);
        } catch (e) {
          warnings.push("Preview rendering failed: " + (e && e.message ? e.message : e));
        }
      }

      // Status
      const summaryStatus = errors.length ? "FAIL" : (warnings.length ? "WARN" : "PASS");
      return finish({errors,warnings,info,summaryStatus,meta:{zipKB:zipSizeKB,totalKB:totalUnzippedKB,initialKB}});
    }

    function finish(payload){
      hideToast();

      // If FAIL, show top error banner with reasons
      if (payload.summaryStatus === "FAIL") {
        showAlert(payload.errors && payload.errors.length ? payload.errors : "The file failed validation.");
      } else {
        hideAlert();
      }

      showResults(payload);
    }

    function showResults({errors,warnings,info,summaryStatus,meta={}}){
      $("#results").classList.remove("hidden");
      $("#details").classList.remove("hidden");

      const summary = $("#summary");
      const tone = summaryStatus === "PASS" ? "bg-blue-100 border-blue-300" :
                   summaryStatus === "WARN" ? "bg-blue-50 border-blue-200" :
                   "bg-blue-50 border-blue-300";
      summary.innerHTML = `
        <div class="rounded-2xl border p-4 ${tone}">
          <div class="flex items-center gap-3">
            <div class="badge">${summaryStatus}</div>
            <div class="text-sm text-blue-900">
              Errors: <strong>${errors.length}</strong> · Warnings: <strong>${warnings.length}</strong>
            </div>
          </div>
        </div>`;

      const eul = $("#errors"); eul.innerHTML = "";
      errors.forEach(e => { const li = document.createElement("li"); li.textContent = e; eul.appendChild(li); });

      const wul = $("#warnings"); wul.innerHTML = "";
      warnings.forEach(w => { const li = document.createElement("li"); li.textContent = w; wul.appendChild(li); });

      const inf = $("#info"); inf.innerHTML = "";
      info.forEach(i => { const p = document.createElement("div"); p.textContent = "• " + i; inf.appendChild(p); });

      const payload = { status: summaryStatus, errors, warnings, info, meta };
      $("#downloadJson").onclick = () =>
        downloadBlob(JSON.stringify(payload, null, 2), "h5-validator-results.json", "application/json");

      const rows = []
        .concat(errors.map(m => ({category:"ERROR", message:m})))
        .concat(warnings.map(m => ({category:"WARNING", message:m})));
      const csv = "category,message\n" + rows.map(r => JSON.stringify(r.category) + "," + JSON.stringify(r.message)).join("\n");
      $("#downloadCsv").onclick = () => downloadBlob(csv, "h5-validator-results.csv", "text/csv");
    }

    function downloadBlob(content, filename, type){
      const blob = new Blob([content], {type});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename; document.body.appendChild(a); a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 200);
    }

    // ===== Preview builder =====
    const MIME = {
      "html":"text/html","htm":"text/html","css":"text/css","js":"text/javascript","mjs":"text/javascript",
      "png":"image/png","jpg":"image/jpeg","jpeg":"image/jpeg","gif":"image/gif","webp":"image/webp","svg":"image/svg+xml",
      "mp4":"video/mp4","webm":"video/webm","ogg":"video/ogg",
      "mp3":"audio/mpeg","wav":"audio/wav","json":"application/json","txt":"text/plain","woff":"font/woff","woff2":"font/woff2","ttf":"font/ttf","otf":"font/otf"
    };

    async function buildPreview(files, indexFile){
      // 1) Create blob URLs for all assets
      const urlMap = new Map(); // normalized path -> blobURL
      function norm(p){ return (p || "").replace(/^\.?\//,''); }
      // First pass: create blob URLs (text/binary) for each file
      for (const f of files){
        if (!f.bin) continue; // skip if couldn't read
        const type = MIME[f.ext] || "application/octet-stream";
        const blob = new Blob([f.bin], {type});
        const u = URL.createObjectURL(blob);
        urlMap.set(norm(f.path), u);
        previewUrls.push(u);
      }

      // 2) Rewrite CSS url(...) to blob URLs (so nested images/fonts load)
      for (const f of files.filter(x => x.ext === "css" && typeof x.text === "string")){
        const baseDir = norm(f.path).replace(/\/[^\/]*$/,""); // directory of this css
        const rewritten = (f.text || "").replace(/url\(([^)]+)\)/g, (m, raw) => {
          let ref = raw.trim().replace(/^['"]|['"]$/g,"");
          if (/^data:|^https?:|^\/\//i.test(ref)) return m; // leave absolute/data
          const joined = baseDir ? (baseDir + "/" + ref).replace(/^\//,'') : ref.replace(/^\//,'');
          const target = urlMap.get(norm(joined));
          return target ? `url(${target})` : m;
        });
        const blob = new Blob([rewritten], {type:"text/css"});
        const u = URL.createObjectURL(blob);
        previewUrls.push(u);
        urlMap.set(norm(f.path), u); // replace the css path to the rewritten blob URL
      }

      // 3) Rewrite the index.html to point to blob URLs
      const parser = new DOMParser();
      const doc = parser.parseFromString(indexFile.text || "", "text/html");

      function rewriteAttr(selector, attr){
        doc.querySelectorAll(selector).forEach(el => {
          const v = el.getAttribute(attr);
          if (!v || /^data:|^https?:|^\/\//i.test(v) || /^#/.test(v)) return;
          const idxDir = norm(indexFile.path).replace(/\/index\.html$/i, "");
          let joined = v.replace(/^\.?\//,'');
          if (idxDir) joined = (idxDir ? (idxDir + "/" + joined) : joined).replace(/^\//,'');
          const blobUrl = urlMap.get(norm(joined));
          if (blobUrl) el.setAttribute(attr, blobUrl);
        });
      }

      rewriteAttr("script[src]", "src");
      rewriteAttr('link[rel="stylesheet"][href]', "href");
      rewriteAttr("img[src]", "src");
      rewriteAttr("video source[src]", "src");
      rewriteAttr("audio source[src]", "src");

      // 4) Serialize modified HTML and show in iframe
      const htmlStr = "<!DOCTYPE html>\n" + doc.documentElement.outerHTML;
      const htmlBlob = new Blob([htmlStr], {type:"text/html"});
      const htmlUrl = URL.createObjectURL(htmlBlob);
      previewUrls.push(htmlUrl);

      const frame = $("#previewFrame");
      frame.src = htmlUrl;
      $("#previewCard").style.display = "block";
    }
  </script>
</body>
</html>
